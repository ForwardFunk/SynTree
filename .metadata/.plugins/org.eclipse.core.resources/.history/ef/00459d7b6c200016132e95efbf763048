package smt_helper;

import ast_utils.ASTStore;

import com.microsoft.z3.*;


import java.util.ArrayList;
import java.util.HashMap;

import utils.*;


public class SynContext extends Context {
	
	private ArrayList<Pair<Integer, Integer>> srcDstPairs;
	private ASTStore astStore;
	private int instrNo;
	
	private Expr[] instrIndVars;
	
	public SynContext(HashMap<String, String> cfg, ASTStore astStore) {
		super(cfg);
		this.astStore = astStore;
		instrNo = 1;
		srcDstPairs = new ArrayList<Pair<Integer, Integer>>();
	}
		
	public void setInstrNo(int instrNo) {
		this.instrNo = instrNo;
	}
	
	public void addSrcDstPair(Integer src, Integer dst) {
		srcDstPairs.add(new Pair<Integer, Integer>(src, dst));
	}
	
	/* Following method tries to generate the following formula. 
	 * If instrNo is 1 and DSL opCnt is 3 the following is generated.
	 *  src = 3, dst = 1
		0: (declare-const dst Int)
		1: (assert 
		2: (exists ((op Int)) 
		3:	(and 
		4:		(ite (= op 1) 
		5:			(= dst (up 3))
		6:			(ite (= op 2)
		7:				(= dst (down-first 3))
		8:				(= dst (down-last 3))))
		9:		(= dst 1))))
	 */
	public BoolExpr mkSynthesisFormula() throws Exception {
		// TODO mkExists
		
		if (instrNo == 0) 
			throw new Exception("Cannot synthesise a program with 0 instructions...");
		
		if (DSLHelper.OP_CNT == 0) 
			throw new Exception("Cannot synthesise a program with empty DSL...");
		
		// DSL op indices as bound variables for existential quantifier
		// Line 2 in above example
		//Expr[] opInd = new Expr[instrNo];	
		Sort[] instrIndSorts = new Sort[instrNo];
		Symbol[] instrIndNames = new Symbol[instrNo];
		instrIndVars = new Expr[instrNo];
		ArrayList<IntExpr[]> dstVars = new ArrayList<IntExpr[]>();
		
		
		// Initialize Op variables as switches for DSL operations
		for (int i = 0; i < instrNo; i++) {
			instrIndSorts[i] = mkIntSort();
			instrIndNames[i] = mkSymbol("op"+i);
			instrIndVars[i] = mkConst(instrIndNames[i], instrIndSorts[i]);
		}
		
		// Initialize destination variables (chained in sequence for each program, one chain for each in/out pair)
		for (int i = 0; i < srcDstPairs.size(); i++) {
			IntExpr[] dstVar = new IntExpr[instrNo];
			for (int j = 0; j < instrNo; j++) {
				dstVar[j] = mkIntConst("dst"+"_"+i+"_"+j);			
			}	
			dstVars.add(dstVar);
		}
		
		
		Expr existsBody = null;
		for (int i = 0; i < srcDstPairs.size(); i++) {
			
			// Add first nested ITE and the final equality
			Expr nestITE = mkNestedITE(instrIndVars[0], dstVars.get(i)[0], mkInt(srcDstPairs.get(i).first), 0);
			BoolExpr reachedDst = mkEq(dstVars.get(i)[instrNo-1], mkInt(srcDstPairs.get(i).second));
			//BoolExpr boolNestITE = mk
			BoolExpr currPairBody = mkAnd((BoolExpr) nestITE, reachedDst);
			
			// For each following instruction in the sequence,
			// add a ITE switch for choosing the instruction as a nested ITE 
			for (int j = 1; j < instrNo; j++) {
				nestITE = mkNestedITE(instrIndVars[j], dstVars.get(i)[j], dstVars.get(i)[j-1]/*mkInt(inOutPairs.get(i).first)*/, 0);
				currPairBody = mkAnd((BoolExpr) nestITE, (BoolExpr) currPairBody);
			}
			
			// In first iteration, just assign currPairBody to existsBody
			if (existsBody == null) {
				existsBody = currPairBody;
			} else {
				existsBody = mkAnd((BoolExpr) existsBody, currPairBody);
			}
		}
		
		// Introduce a constraint for DSL operation switches: op[i] >= 0 && op[i] <= MAX_NUM_OF_INSTRUCTIONS-1
		BoolExpr existDSLOpSwitches = mkExists(instrIndSorts, instrIndNames, existsBody, 1, null, null, null, null);
		BoolExpr constraintsDSLOpSwitches = mkAnd(
												mkGe((ArithExpr) instrIndVars[0], mkInt(0)), 
												mkLe((ArithExpr) instrIndVars[0], mkInt(DSLHelper.OP_CNT-1)));
		for (int i = 0; i < instrNo; i++) {
			constraintsDSLOpSwitches = mkAnd(constraintsDSLOpSwitches, 
											mkAnd(
												mkGe((ArithExpr) instrIndVars[i], mkInt(0)), 
												mkLe((ArithExpr) instrIndVars[i], mkInt(DSLHelper.OP_CNT-1))));
		}
		
		BoolExpr synFormula = mkAnd(constraintsDSLOpSwitches, existDSLOpSwitches);
		return synFormula;
	}
	
	
	/* Recursive function of generating a nested ITE constraint in the following example form:
	 * 
		4:		(ite (= op 1) 
		5:			(= dst (up 3))
		6:			(ite (= op 2)
		7:				(= dst (down-first 3))
		8:				(= dst (down-last 3))))
	 */
	private Expr mkNestedITE(Expr opIdxVar, IntExpr dstVar, IntExpr srcVar, int currOpInd) {
		//int currOpInd = DSLHelper.opCnt-level-1;
		BoolExpr cond = mkEq(opIdxVar, mkInt(currOpInd));
		//Expr tBranch = mkEq(dstVar, DSLHelper.getDSLOp(currOpInd, srcVar, astStore, this));
		Expr tBranch = DSLHelper.getDSLOp(currOpInd, srcVar, dstVar, astStore, this);
		System.out.println(currOpInd);
		if (currOpInd == DSLHelper.OP_CNT - 1) {
			//Expr fBranch = mkEq(dstVar, DSLHelper.getDSLOp(currOpInd+1, srcVar, astStore, this));
			Expr fBranch = DSLHelper.getDSLOp(currOpInd, srcVar, dstVar, astStore, this);
			return mkITE(cond, tBranch, fBranch);
		} else {
			Expr fBranch = mkNestedITE(opIdxVar, dstVar, srcVar, currOpInd+1);
			return mkITE(cond, tBranch, fBranch);
		}
	}
	
	
} 
