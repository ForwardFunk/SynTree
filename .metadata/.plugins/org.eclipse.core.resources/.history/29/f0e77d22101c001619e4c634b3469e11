package smt;

import com.microsoft.z3.*;

import java.util.ArrayList;
import java.util.HashMap;

import utils.*;


public class SynContext extends Context {
	
	private ArrayList<Pair<Integer, Integer>> inOutPairs;
	private int instrNo;
	
	public SynContext(HashMap<String, String> cfg) {
		super(cfg);
		instrNo = 1;
		inOutPairs = new ArrayList<Pair<Integer, Integer>>();
	}
		
	public void setInstrNo(int instrNo) {
		this.instrNo = instrNo;
	}
	
	public void addInOutPair(Integer in, Integer out) {
		inOutPairs.add(new Pair<Integer, Integer>(in, out));
	}
	
	/* Following method tries to generate the following formula. 
	 * If instrNo is 1 and DSL opCnt is 3 the following is generated.
	 * 
		0: (declare-const dst Int)
		1: (assert 
		2: (exists ((op Int)) 
		3:	(and 
		4:		(ite (= op 1) 
		5:			(= dst (up 3))
		6:			(ite (= op 2)
		7:				(= dst (down-first 3))
		8:				(= dst (down-last 3))))
		9:		(= dst 1))))
	 */
	public BoolExpr mkSynthesisFormula() throws Exception {
		// TODO mkExists
		
		if (instrNo == 0) 
			throw new Exception("Cannot synthesise a program with 0 instructions...");
		
		if (DSL.opCnt == 0) 
			throw new Exception("Cannot synthesise a program with empty DSL...");
		
		// DSL op indices as bound variables for existential quantifier
		// Line 2 in above example
		Expr[] opInd = new Expr[instrNo];	
		IntExpr[] dstVars = new IntExpr[instrNo];
		for (int i = 0; i < instrNo; i++) {
			opInd[i] = mkBound(instrNo-1-i, this.getIntSort());
			dstVars[i] = mkIntConst("dst"+i);			
		}
		
		Expr existsBody = null;
		for (int i = 0; i < inOutPairs.size(); i++) {
			
			// Add first nested ITE and the final equality
			Expr nestITE = mkNestedITE(opInd[0], dstVars[0], mkInt(inOutPairs.get(i).first), DSL.opCnt - 2);
			BoolExpr reachedDst = mkEq(dstVars[instrNo-1], mkInt(inOutPairs.get(i).second));
			//BoolExpr boolNestITE = mk
			existsBody = mkAnd((BoolExpr) nestITE, reachedDst);
			
			// For each following instruction in the sequence,
			// add a ITE switch for choosing the instruction as a nested ITE 
			for (int j = 1; j < instrNo; j++) {
				nestITE = mkNestedITE(opInd[j], dstVars[j], mkInt(inOutPairs.get(i).first), DSL.opCnt-2);
				existsBody = mkAnd((BoolExpr) nestITE, (BoolExpr) existsBody);
			}			
		}
		
		BoolExpr synFormula = mkExists(opInd, existsBody, 1, null, null, mkSymbol("q1"), mkSymbol("skid1"));
		
		return synFormula;
	}
	
	private Expr mkNestedITE(Expr opIndVar, IntExpr dstVar, IntExpr srcVar, int level) {
		int currOpInd = DSL.opCnt-level-2;
		BoolExpr cond = mkEq(opIndVar, mkInt(currOpInd));
		Expr tBranch = mkEq(dstVar, DSL.getDSLOp(currOpInd, srcVar, this));
		
		if (level == 0) {
			Expr fBranch = mkEq(dstVar, DSL.getDSLOp(currOpInd+1, srcVar, this));
			return mkITE(cond, tBranch, fBranch);
		} else {
			Expr fBranch = mkNestedITE(opIndVar, dstVar, srcVar, level-1);
			return mkITE(cond, tBranch, fBranch);
		}
	}
} 
