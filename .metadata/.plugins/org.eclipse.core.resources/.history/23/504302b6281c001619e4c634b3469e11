package smt;

import com.microsoft.z3.*;

import java.util.ArrayList;
import java.util.HashMap;

import utils.*;


public class SynContext extends Context {
	
	private ArrayList<Pair<Integer, Integer>> inOutPairs;
	private int instrNo;
	
	public SynContext(HashMap<String, String> cfg) {
		super(cfg);
		instrNo = 1;
		inOutPairs = new ArrayList<Pair<Integer, Integer>>();
	}
		
	public void setInstrNo(int instrNo) {
		this.instrNo = instrNo;
	}
	
	public void addInOutPair(Integer in, Integer out) {
		inOutPairs.add(new Pair<Integer, Integer>(in, out));
	}
	
	/* Following method tries to generate the following formula. 
	 * If instrNo is 1 and DSL opCnt is 3 the following is generated.
	 * 
		0: (declare-const dst Int)
		1: (assert 
		2: (exists ((op Int)) 
		3:	(and 
		4:		(ite (= op 1) 
		5:			(= dst (up 3))
		6:			(ite (= op 2)
		7:				(= dst (down-first 3))
		8:				(= dst (down-last 3))))
		9:		(= dst 1))))
	 */
	public BoolExpr mkSynthesisFormula() throws Exception {
		// TODO mkExists
		
		if (instrNo == 0) 
			throw new Exception("Cannot synthesise a program with 0 instructions...");
		
		if (DSL.opCnt == 0) 
			throw new Exception("Cannot synthesise a program with empty DSL...");
		
		// DSL op indices as bound variables for existential quantifier
		// Line 2 in above example
		//Expr[] opInd = new Expr[instrNo];	
		Sort[] instrIndSorts = new Sort[instrNo];
		Symbol[] instrIndNames = new Symbol[instrNo];
		Expr[] instrIndVars = new Expr[instrNo];
		ArrayList<IntExpr[]> dstVars = new ArrayList<IntExpr[]>();
		
		for (int i = 0; i < inOutPairs.size(); i++) {
			IntExpr[] dstVar = new IntExpr[instrNo];
			for (int j = 0; j < instrNo; j++) {
				//opInd[i] = mkBound(instrNo-1-i, this.getIntSort());
				instrIndSorts[i] = mkIntSort();
				instrIndNames[i] = mkSymbol("op"+i);
				instrIndVars[i] = mkConst(instrIndNames[i], instrIndSorts[i]);
				dstVar[i] = mkIntConst("dst"+i);			
			}	
			dstVars.add(dstVar);
		}
		
		
		Expr existsBody = null;
		for (int i = 0; i < inOutPairs.size(); i++) {
			
			// Add first nested ITE and the final equality
			Expr nestITE = mkNestedITE(instrIndVars[0], dstVars.get(i)[0], mkInt(inOutPairs.get(i).first), DSL.opCnt - 2);
			BoolExpr reachedDst = mkEq(dstVars[instrNo-1], mkInt(inOutPairs.get(i).second));
			//BoolExpr boolNestITE = mk
			BoolExpr currPairBody = mkAnd((BoolExpr) nestITE, reachedDst);
			
			// For each following instruction in the sequence,
			// add a ITE switch for choosing the instruction as a nested ITE 
			for (int j = 1; j < instrNo; j++) {
				nestITE = mkNestedITE(instrIndVars[j], dstVars[j], mkInt(inOutPairs.get(i).first), DSL.opCnt-2);
				currPairBody = mkAnd((BoolExpr) nestITE, (BoolExpr) currPairBody);
			}
			
			// In first iteration, just assign currPairBody to existsBody
			if (existsBody == null) {
				existsBody = currPairBody;
			} else {
				existsBody = mkAnd((BoolExpr) existsBody, currPairBody);
			}
		}
		
		System.out.println(existsBody.toString());		
		//Expr[] noPats = {existsBody};
		
		//BoolExpr body = mkEq(mkInt(1), mkInt(2));
		BoolExpr synFormula = mkExists(instrIndSorts, instrIndNames,
				existsBody, 1, null, null, mkSymbol("q1"), mkSymbol("skid1"));
		
		return synFormula;
	}
	
	private Expr mkNestedITE(Expr opIndVar, IntExpr dstVar, IntExpr srcVar, int level) {
		int currOpInd = DSL.opCnt-level-2;
		BoolExpr cond = mkEq(opIndVar, mkInt(currOpInd));
		Expr tBranch = mkEq(dstVar, DSL.getDSLOp(currOpInd, srcVar, this));
		
		if (level == 0) {
			Expr fBranch = mkEq(dstVar, DSL.getDSLOp(currOpInd+1, srcVar, this));
			return mkITE(cond, tBranch, fBranch);
		} else {
			Expr fBranch = mkNestedITE(opIndVar, dstVar, srcVar, level-1);
			return mkITE(cond, tBranch, fBranch);
		}
	}
} 
