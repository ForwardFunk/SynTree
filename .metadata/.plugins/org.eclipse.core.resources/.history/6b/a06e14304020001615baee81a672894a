package dsl;

import ast_utils.ASTStore;

import com.microsoft.z3.*;

/*
 * NOTE: On every add of a new DSL operation:
 * 	- update opCnt
 * 	- add definition as a private method,
 *  - add case to getDSLOp
 */

public class DSLHelper {
	
	public static int opCnt = 5;
	
	// Will be called to get operation definitions,
	// during generation of the Synthesis formula
	public static ArithExpr getDSLOp(int opIdx, IntExpr ndIdx, ASTStore astStore, Context z3Ctx) {
		switch (opIdx) {
		case 0:
			return up(ndIdx, astStore, z3Ctx);
		case 1:
			return downFirst(ndIdx, astStore, z3Ctx);
		case 2:
			return downLast(ndIdx, astStore, z3Ctx);
		case 3:
			return prevNodeValue(ndIdx, astStore, z3Ctx);
		case 4:
			return nop(ndIdx, z3Ctx);
	    // default shouldn't be called in any case
		default:
			return null;
		}			
	}

	// Defined DSL operations
	private static ArithExpr up(IntExpr node, ASTStore astStore, Context z3Ctx) {		
		// BT definition:
		/*IntExpr two = z3Ctx.mkInt(2);		
		ArithExpr up = z3Ctx.mkDiv(node, two);
		return up;*/
		
		// AST definition: 
		/*if (node.isIntNum()) {
			int ndIdx = node.toString
		}*/
		int ndIdx = Integer.parseInt(node.toString());
		//int ndIdx = ((IntNum) node).getInt();
		return z3Ctx.mkInt(astStore.getNdParentIdx(ndIdx));
	}
	
	private static ArithExpr downFirst(IntExpr node, ASTStore astStore, Context z3Ctx) {
		// BT definition:		
		/*IntExpr two = z3Ctx.mkInt(2);	
		ArithExpr df = z3Ctx.mkMul(node, two);
		return df;*/
		
		// AST definition:
		int ndIdx = ((IntNum) node).getInt();
		Integer[] ndChildrenIdx = astStore.getNdChildrenIdx(ndIdx);
		if (ndChildrenIdx.length == 0) {
			return node; // TODO: remove this branch after introducing constraints for no-children in the syn. formula
		} else {
			return z3Ctx.mkInt(ndChildrenIdx[0]);
		}
	}
	
	private static ArithExpr downLast(IntExpr node, ASTStore astStore, Context z3Ctx) {
		// BT definition
		/*IntExpr two = z3Ctx.mkInt(2);	
		IntExpr one = z3Ctx.mkInt(1);		
		ArithExpr df = z3Ctx.mkMul(node, two);
		ArithExpr dl = z3Ctx.mkAdd(df, one);
		return dl;*/
		
		// AST definition:
				int ndIdx = ((IntNum) node).getInt();
				Integer[] ndChildrenIdx = astStore.getNdChildrenIdx(ndIdx);
				if (ndChildrenIdx.length == 0) {
					return node; // TODO: remove this branch after introducing constraints for no-children in the syn. formula
				} else {
					return z3Ctx.mkInt(ndChildrenIdx[ndChildrenIdx.length-1]);
				}
	}
	
	private static ArithExpr prevNodeValue(IntExpr node, ASTStore astStore, Context z3Ctx) {
		int ndIdx = ((IntNum) node).getInt();
		return z3Ctx.mkInt(astStore.getNdPrevValue(ndIdx));
	}
	
	private static ArithExpr nop(IntExpr node, Context z3Ctx) {
		return node;
	}
	
	private static Expr mkNestedITE(Expr opIdxVar, IntExpr dstVar, IntExpr srcVar, int level) {
		int currOpInd = DSLHelper.opCnt-level-2;
		BoolExpr cond = mkEq(opIdxVar, mkInt(currOpInd));
		Expr tBranch = mkEq(dstVar, DSLHelper.getDSLOp(currOpInd, srcVar, astStore, this));
		
		if (level == 0) {
			Expr fBranch = mkEq(dstVar, DSLHelper.getDSLOp(currOpInd+1, srcVar, astStore, this));
			return mkITE(cond, tBranch, fBranch);
		} else {
			Expr fBranch = mkNestedITE(opIdxVar, dstVar, srcVar, level-1);
			return mkITE(cond, tBranch, fBranch);
		}
	}
	
}
